---
layout: archive
title: "Tetris"
permalink: /game/tetris/
author_profile: true
---

<a href="/game/" class="back-link" style="display:inline-flex;align-items:center;gap:.4rem;margin-bottom:1rem;text-decoration:none;color:#3498db;font-weight:600;">⟵ Back to Games</a>

<h3>Tetris</h3>
<p>Stack falling blocks to clear lines. Click Start to begin. Use A/D or ←/→ to move, W or ↑ to rotate, S or ↓ to soft drop, and Space to hard drop. Colliding at the top ends the game.</p>

<style>
  .game-wrapper {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    align-items: flex-start;
    margin-top: 1rem;
    padding: 1.5rem;
    background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }
  .tetris-game {
    background: #ffffff;
    border: 2px solid #e1e8ed;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    transition: transform 0.2s ease;
  }
  .tetris-game:hover { transform: translateY(-2px); }
  #tetrisCanvas {
    background: #111827;
    border: 3px solid #374151;
    border-radius: 8px;
    display: block;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.35);
  }
  .tetris-sidebar {
    min-width: 250px;
    background: #ffffff;
    padding: 1.5rem;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
  }
  .tetris-stats {
    display: flex;
    gap: 1rem;
    align-items: center;
    margin: 0.5rem 0 1rem;
    font-weight: 700;
    font-size: 1.05rem;
    color: #2c3e50;
    flex-wrap: wrap;
  }
  .tetris-stat {
    background: #f3f4f6;
    padding: .35rem .6rem;
    border-radius: 8px;
  }
  .tetris-controls {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  .tetris-controls button {
    padding: 0.65rem 1.25rem;
    border-radius: 8px;
    border: none;
    background: #3498db;
    color: #fff;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }
  .tetris-controls button:hover { background: #2980b9; transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
  .tetris-controls button.primary { background: #e74c3c; }
  .tetris-controls button.primary:hover { background: #c0392b; }
  .tetris-controls button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
  .tetris-info { font-size: 0.95rem; color: #7f8c8d; margin-top: 1rem; line-height: 1.6; }
  @media (max-width: 768px) {
    .game-wrapper { flex-direction: column; gap: 1rem; padding: 1rem; }
    .tetris-sidebar { min-width: auto; }
    #tetrisCanvas { width: 100%; height: auto; max-width: 300px; }
    .tetris-controls { justify-content: center; }
  }
</style>

<div class="tetris-game-wrapper game-wrapper">
  <div class="tetris-game">
    <canvas id="tetrisCanvas" width="240" height="480"></canvas>
  </div>
  <div class="tetris-sidebar">
    <div class="tetris-stats">
      <div class="tetris-stat">Score: <span id="tetrisScore">0</span></div>
      <div class="tetris-stat">Lines: <span id="tetrisLines">0</span></div>
      <div class="tetris-stat">Level: <span id="tetrisLevel">1</span></div>
    </div>
    <div class="tetris-controls">
      <button id="tetrisStartBtn" class="primary">Start</button>
      <button id="tetrisPauseBtn">Pause</button>
      <button id="tetrisResetBtn">Reset</button>
    </div>
    <div class="tetris-info">
      - The game does not start automatically. Click Start.<br/>
      - Move: A/D or ←/→, Rotate: W or ↑, Soft drop: S or ↓, Hard drop: Space.<br/>
      - Clear complete horizontal lines to score and level up.
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('tetrisCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('tetrisScore');
  const linesEl = document.getElementById('tetrisLines');
  const levelEl = document.getElementById('tetrisLevel');
  const startBtn = document.getElementById('tetrisStartBtn');
  const pauseBtn = document.getElementById('tetrisPauseBtn');
  const resetBtn = document.getElementById('tetrisResetBtn');

  const COLS = 10;
  const ROWS = 20;
  const BLOCK = 24; // canvas is 240x480

  const COLORS = {
    I: '#06b6d4', // cyan
    J: '#3b82f6', // blue
    L: '#f59e0b', // orange
    O: '#fbbf24', // yellow
    S: '#22c55e', // green
    T: '#8b5cf6', // purple
    Z: '#ef4444'  // red
  };

  const SHAPES = {
    I: [
      [ [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0] ]
    ],
    J: [
      [ [1,0,0],
        [1,1,1],
        [0,0,0] ]
    ],
    L: [
      [ [0,0,1],
        [1,1,1],
        [0,0,0] ]
    ],
    O: [
      [ [1,1],
        [1,1] ]
    ],
    S: [
      [ [0,1,1],
        [1,1,0],
        [0,0,0] ]
    ],
    T: [
      [ [0,1,0],
        [1,1,1],
        [0,0,0] ]
    ],
    Z: [
      [ [1,1,0],
        [0,1,1],
        [0,0,0] ]
    ]
  };

  function rotateMatrix(m) {
    const N = m.length;
    const res = Array.from({ length: N }, () => Array(N).fill(0));
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        res[x][N - 1 - y] = m[y][x];
      }
    }
    return res;
  }

  function trimMatrix(m) {
    // remove empty rows/cols around the piece to compute width/height easily
    let top = 0, bottom = m.length - 1, left = 0, right = m[0].length - 1;
    // top
    while (top <= bottom && m[top].every(v => v === 0)) top++;
    // bottom
    while (bottom >= top && m[bottom].every(v => v === 0)) bottom--;
    // left
    while (left <= right && m.every(row => row[left] === 0)) left++;
    // right
    while (right >= left && m.every(row => row[right] === 0)) right--;
    const res = [];
    for (let y = top; y <= bottom; y++) {
      res.push(m[y].slice(left, right + 1));
    }
    return res.length ? res : [[0]];
  }

  function createBoard() {
    return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  }

  function randomPiece() {
    const types = Object.keys(SHAPES);
    const type = types[Math.floor(Math.random() * types.length)];
    // base matrix (clone) and precompute rotation state 0
    let matrix = SHAPES[type][0].map(row => row.slice());
    // tetris pieces typically in 4x4 for I, others 3x3/2x2; normalize to square for rotation simplicity
    const size = Math.max(matrix.length, matrix[0].length);
    // pad to square
    if (matrix.length !== size || matrix[0].length !== size) {
      const padded = Array.from({ length: size }, () => Array(size).fill(0));
      for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < matrix[0].length; x++) {
          padded[y][x] = matrix[y][x];
        }
      }
      matrix = padded;
    }
    return {
      type,
      color: COLORS[type],
      matrix,
      row: 0,
      col: Math.floor((COLS - trimMatrix(matrix)[0].length) / 2)
    };
  }

  let board, current, next, score, lines, level, running, paused, loopId, speed;

  function reset() {
    board = createBoard();
    current = randomPiece();
    next = randomPiece();
    score = 0;
    lines = 0;
    level = 1;
    speed = calcSpeed();
    running = false;
    paused = false;
    updateUI();
    draw();
  }

  function calcSpeed() {
    // base 700ms, faster every 10 lines, min 120ms
    const lvl = Math.floor(lines / 10) + 1;
    level = lvl;
    return Math.max(120, 700 - (lvl - 1) * 60);
  }

  function updateUI() {
    if (scoreEl) scoreEl.textContent = String(score);
    if (linesEl) linesEl.textContent = String(lines);
    if (levelEl) levelEl.textContent = String(level);
  }

  function collide(b, p, offX = 0, offY = 0, mat = null) {
    const m = mat || p.matrix;
    const H = m.length, W = m[0].length;
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        if (m[y][x]) {
          const nx = p.col + x + offX;
          const ny = p.row + y + offY;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (ny >= 0 && b[ny][nx]) return true;
        }
      }
    }
    return false;
  }

  function merge(b, p) {
    const m = p.matrix, H = m.length, W = m[0].length;
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        if (m[y][x]) {
          const ny = p.row + y;
          const nx = p.col + x;
          if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
            b[ny][nx] = p.color;
          }
        }
      }
    }
  }

  function clearLines() {
    let cleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) {
          continue outer;
        }
      }
      // row y is full
      const row = board.splice(y, 1)[0].fill(0);
      board.unshift(Array(COLS).fill(0));
      cleared++;
      y++; // re-check same y after unshift
    }
    if (cleared > 0) {
      score += [0, 100, 300, 500, 800][Math.min(cleared, 4)];
      lines += cleared;
      speed = calcSpeed();
      updateLoop();
      updateUI();
    }
  }

  function drawCell(x, y, color) {
    const px = x * BLOCK;
    const py = y * BLOCK;
    ctx.fillStyle = color;
    ctx.fillRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 1;
    ctx.strokeRect(px + 0.5, py + 0.5, BLOCK - 1, BLOCK - 1);
  }

  function drawGrid() {
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK + 0.5, 0);
      ctx.lineTo(x * BLOCK + 0.5, canvas.height);
      ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK + 0.5);
      ctx.lineTo(canvas.width, y * BLOCK + 0.5);
      ctx.stroke();
    }
  }

  function drawBoard() {
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x]) {
          drawCell(x, y, board[y][x]);
        }
      }
    }
  }

  function drawPiece(p) {
    const m = p.matrix;
    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[0].length; x++) {
        if (m[y][x] && p.row + y >= 0) {
          drawCell(p.col + x, p.row + y, p.color);
        }
      }
    }
  }

  function drawOverlay(text) {
    ctx.fillStyle = 'rgba(17,24,39,0.65)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#e5e7eb';
    ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 8);
    ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.fillText('Click Reset to play again', canvas.width/2, canvas.height/2 + 20);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    drawBoard();
    if (current) drawPiece(current);
    if (!running && score + lines > 0) {
      drawOverlay('Game Over');
    } else if (paused) {
      drawOverlay('Paused');
    }
  }

  function spawn() {
    current = next;
    next = randomPiece();
    current.row = -1; // start slightly above
    current.col = Math.floor((COLS - trimMatrix(current.matrix)[0].length) / 2);
    current.row = 0;
    if (collide(board, current, 0, 0)) {
      running = false;
      clearInterval(loopId);
      draw();
    }
  }

  function moveDown() {
    if (collide(board, current, 0, 1)) {
      merge(board, current);
      clearLines();
      spawn();
      return false;
    } else {
      current.row++;
      return true;
    }
  }

  function moveHoriz(dx) {
    if (!collide(board, current, dx, 0)) {
      current.col += dx;
    }
  }

  function rotatePiece() {
    const rotated = rotateMatrix(current.matrix);
    // try original position
    if (!collide(board, current, 0, 0, rotated)) {
      current.matrix = rotated;
      return;
    }
    // simple wall kicks: try shifts -1, +1, -2, +2
    const kicks = [-1, 1, -2, 2];
    for (const k of kicks) {
      if (!collide(board, current, k, 0, rotated)) {
        current.col += k;
        current.matrix = rotated;
        return;
      }
    }
    // if none, do nothing
  }

  function hardDrop() {
    let dropped = 0;
    while (moveDown()) dropped++;
    score += Math.max(0, dropped - 1) * 2; // small bonus
    updateUI();
  }

  function tick() {
    if (!running || paused) return;
    moveDown();
    draw();
  }

  function updateLoop() {
    if (loopId) clearInterval(loopId);
    loopId = setInterval(() => { tick(); }, speed);
  }

  function start() {
    if (running) return;
    running = true;
    paused = false;
    updateLoop();
  }

  function pause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    draw();
  }

  function doReset() {
    if (loopId) clearInterval(loopId);
    reset();
    pauseBtn.textContent = 'Pause';
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (!running || paused) {
      // allow resume via space key
      if (k === ' ') { e.preventDefault(); start(); }
      return;
    }
    if (k === 'ArrowLeft' || k === 'a' || k === 'A') {
      moveHoriz(-1);
    } else if (k === 'ArrowRight' || k === 'd' || k === 'D') {
      moveHoriz(1);
    } else if (k === 'ArrowDown' || k === 's' || k === 'S') {
      if (moveDown()) score += 1, updateUI();
    } else if (k === 'ArrowUp' || k === 'w' || k === 'W') {
      rotatePiece();
    } else if (k === ' ') {
      e.preventDefault();
      hardDrop();
    } else if (k === 'p' || k === 'P') {
      pause();
    }
    draw();
  }, { passive: false });

  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', pause);
  resetBtn.addEventListener('click', doReset);

  reset();
})();
</script>
