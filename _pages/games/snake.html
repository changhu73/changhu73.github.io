---
layout: archive
title: "Snake"
permalink: /game/snake/
author_profile: true
---

<a href="/game/" class="back-link" style="display:inline-flex;align-items:center;gap:.4rem;margin-bottom:1rem;text-decoration:none;color:#3498db;font-weight:600;">⟵ Back to Games</a>

<h3>Snake Game</h3>
<p>Use WASD or Arrow keys to move. On mobile, use the on-screen D-pad or swipe on the canvas. Press Space to pause/resume. Colliding with walls or yourself ends the game.</p>

<style>
  :root {
    --primary-color: #3498db;
    --secondary-color: #2ecc71;
    --danger-color: #e74c3c;
    --background-color: #f5f7fa;
    --card-background: #ffffff;
    --text-color: #2c3e50;
    --border-color: #e1e8ed;
  }

  .game-wrapper {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    align-items: flex-start;
    margin-top: 1rem;
    padding: 1.5rem;
    background: linear-gradient(135deg, var(--background-color) 0%, #c3cfe2 100%);
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }

  .snake-game-wrapper {
    flex-direction: column;
    align-items: center;
  }

  .snake-game {
    background: var(--card-background);
    border: 2px solid var(--border-color);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    transition: transform 0.2s ease;
    margin: 0 auto;
  }

  .snake-game:hover {
    transform: translateY(-2px);
  }

  #snakeCanvas {
    background: #2c3e50;
    border: 3px solid #34495e;
    border-radius: 8px;
    display: block;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
    touch-action: none;
  }

  .snake-sidebar {
    min-width: 0;
    width: 100%;
    max-width: 860px;
    background: var(--card-background);
    padding: 1.5rem;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    margin: 0.75rem auto 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  .snake-stats {
    display: flex;
    gap: 1rem;
    align-items: center;
    justify-content: center;
    margin: 0.5rem 0 1rem;
    font-weight: 700;
    font-size: 1.1rem;
    color: var(--text-color);
  }

  .snake-stats-row {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .stat-item {
    background: var(--background-color);
    padding: 0.5rem 1rem;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
  }

  .snake-controls {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    margin-bottom: 0.75rem;
    justify-content: center;
  }

  .snake-controls button {
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    border: none;
    background: var(--primary-color);
    color: #fff;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }

  .snake-controls button:hover {
    background: #2980b9;
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
  }

  .snake-controls button.primary { background: var(--danger-color); }
  .snake-controls button.primary:hover { background: #c0392b; }
  .snake-controls button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

  .difficulty-selector {
    margin-bottom: 1rem;
  }

  .difficulty-selector select {
    padding: 0.5rem;
    border-radius: 6px;
    border: 1px solid var(--border-color);
    background: var(--card-background);
    font-weight: 600;
  }

  /* On-screen D-pad for touch users */
  .snake-touch-controls {
    display: grid;
    grid-template-columns: 56px 56px 56px;
    grid-template-rows: 56px 56px 56px;
    gap: 8px;
    margin-top: 0.25rem;
  }

  .snake-touch-controls button {
    width: 56px;
    height: 56px;
    border-radius: 10px;
    border: 1px solid #e5e7eb;
    background: #f9fafb;
    color: #111827;
    cursor: pointer;
    font-weight: 700;
    box-shadow: 0 2px 5px rgba(0,0,0,0.06);
    transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
  }

  .snake-touch-controls button:hover { background: #f3f4f6; transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }

  #btnUp { grid-column: 2; grid-row: 1; }
  #btnLeft { grid-column: 1; grid-row: 2; }
  #btnRight { grid-column: 3; grid-row: 2; }
  #btnDown { grid-column: 2; grid-row: 3; }

  .snake-info {
    font-size: 0.95rem;
    color: #7f8c8d;
    margin-top: 0.5rem;
    line-height: 1.6;
  }

  @media (max-width: 768px) {
    .game-wrapper { flex-direction: column; gap: 1rem; padding: 1rem; }
    .snake-sidebar { min-width: auto; }
    .snake-controls { justify-content: center; }
  }
</style>

<div class="snake-game-wrapper game-wrapper">
  <div class="snake-game">
    <canvas id="snakeCanvas" width="480" height="480"></canvas>
  </div>
  <div class="snake-sidebar">
    <div class="snake-stats">
      <div class="snake-stats-row">
        <div class="stat-item">Score: <span id="snakeScore">0</span></div>
        <div class="stat-item">High Score: <span id="highScore">0</span></div>
      </div>
      <div class="snake-stats-row">
        <div class="stat-item">Games: <span id="gamesPlayed">0</span></div>
        <div class="stat-item">Avg Score: <span id="avgScore">0</span></div>
      </div>
    </div>
    <div class="difficulty-selector">
      <label for="difficulty">Difficulty: </label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
    </div>
    <div class="snake-controls">
      <button id="startBtn" class="primary">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
    </div>
    <div class="snake-touch-controls" aria-label="Touch controls" role="group">
      <button id="btnUp" aria-label="Up">▲</button>
      <button id="btnLeft" aria-label="Left">◀</button>
      <button id="btnRight" aria-label="Right">▶</button>
      <button id="btnDown" aria-label="Down">▼</button>
    </div>
    <div class="snake-info">
      - Select difficulty before starting.<br/>
      - Move with WASD or Arrow keys. On mobile, use the on-screen D-pad or swipe on the canvas. Press Space to pause/resume.<br/>
      - Colliding with a wall or yourself ends the game.
    </div>
  </div>
</div>

<script>
class SnakeGame {
  constructor(canvas, scoreEl, highScoreEl, pauseBtn, resetBtn, startBtn, difficultySelect) {
    // Constants
    this.BASE_SPEED = {
      easy: 150,
      medium: 120,
      hard: 90
    };
    this.MIN_SPEED = 50;
    this.SPEED_INCREMENT = 2;
    this.TILE_COUNT_X = 30;
    this.TILE_COUNT_Y = 20;

    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.scoreEl = scoreEl;
    this.highScoreEl = highScoreEl;
    this.pauseBtn = pauseBtn;
    this.resetBtn = resetBtn;
    this.startBtn = startBtn;
    this.difficultySelect = difficultySelect;

    this.tileCountX = this.TILE_COUNT_X;
    this.tileCountY = this.TILE_COUNT_Y;
    this.tileSize = 0;

    this.snake = [];
    this.direction = { x: 1, y: 0 };
    this.nextDirection = { x: 1, y: 0 };
    this.apple = null;
    this.score = 0;
    this.highScore = this.loadHighScore();
    this.running = false;
    this.paused = false;
    this.speed = this.BASE_SPEED.medium;
    this.lastTime = 0;
    this.animationId = null;

    // Game stats
    this.gameStats = {
      gamesPlayed: parseInt(localStorage.getItem('snakeGamesPlayed')) || 0,
      totalScore: parseInt(localStorage.getItem('snakeTotalScore')) || 0,
      bestScore: this.highScore,
      totalPlayTime: parseInt(localStorage.getItem('snakeTotalPlayTime')) || 0
    };

    this.resizeCanvas();
    this.init();
    this.bindEvents();
    this.updateHighScore();
    this.updateStatsDisplay();
  }

  loadHighScore() {
    return parseInt(localStorage.getItem('snakeHighScore')) || 0;
  }

  saveHighScore() {
    localStorage.setItem('snakeHighScore', this.highScore);
  }

  saveStats() {
    localStorage.setItem('snakeGamesPlayed', this.gameStats.gamesPlayed);
    localStorage.setItem('snakeTotalScore', this.gameStats.totalScore);
    localStorage.setItem('snakeTotalPlayTime', this.gameStats.totalPlayTime);
  }

  updateStatsDisplay() {
    const gamesPlayedEl = document.getElementById('gamesPlayed');
    const avgScoreEl = document.getElementById('avgScore');
    if (gamesPlayedEl) gamesPlayedEl.textContent = this.gameStats.gamesPlayed;
    if (avgScoreEl) {
      const avg = this.gameStats.gamesPlayed > 0 ? Math.round(this.gameStats.totalScore / this.gameStats.gamesPlayed) : 0;
      avgScoreEl.textContent = avg;
    }
  }

  resizeCanvas() {
    const ratio = this.tileCountX / this.tileCountY;
    const maxW = Math.floor(window.innerWidth * 0.96);
    const maxH = Math.floor(window.innerHeight * 0.80);
    let width = Math.min(maxW, Math.floor(maxH * ratio));
    let height = Math.floor(width / ratio);
    const cell = Math.max(12, Math.floor(Math.min(width / this.tileCountX, height / this.tileCountY)));
    width = cell * this.tileCountX;
    height = cell * this.tileCountY;
    this.canvas.width = width;
    this.canvas.height = height;
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
    this.tileSize = cell;
  }

  init() {
    const startX = Math.floor(this.tileCountX / 2);
    const startY = Math.floor(this.tileCountY / 2);
    this.snake = [
      { x: startX, y: startY },
      { x: startX - 1, y: startY },
      { x: startX - 2, y: startY }
    ];
    this.direction = { x: 1, y: 0 };
    this.nextDirection = { x: 1, y: 0 };
    this.apple = this.randomEmptyCell();
    this.score = 0;
    this.setDifficulty();
    this.running = false;
    this.paused = false;
    this.updateScore();
    this.draw();
  }

  setDifficulty() {
    const difficulty = this.difficultySelect.value;
    this.speed = this.BASE_SPEED[difficulty] || this.BASE_SPEED.medium;
  }

  updateScore() {
    if (this.scoreEl) this.scoreEl.textContent = this.score;
    if (this.score > this.highScore) {
      this.highScore = this.score;
      this.saveHighScore();
      this.updateHighScore();
    }
  }

  updateHighScore() {
    if (this.highScoreEl) this.highScoreEl.textContent = this.highScore;
  }

  randomEmptyCell() {
    let position;
    do {
      position = {
        x: Math.floor(Math.random() * this.tileCountX),
        y: Math.floor(Math.random() * this.tileCountY)
      };
    } while (this.snake.some(segment => segment.x === position.x && segment.y === position.y));
    return position;
  }

  gameOver() {
    this.running = false;
    cancelAnimationFrame(this.animationId);
    this.gameStats.gamesPlayed++;
    this.gameStats.totalScore += this.score;
    this.saveStats();
    this.updateStatsDisplay();

    this.ctx.fillStyle = 'rgba(44, 62, 80, 0.8)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = '#ecf0f1';
    this.ctx.font = 'bold 32px sans-serif';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('Game Over', this.canvas.width / 2, this.canvas.height / 2 - 15);
    this.ctx.font = '18px sans-serif';
    this.ctx.fillText('Click Reset to play again', this.canvas.width / 2, this.canvas.height / 2 + 25);
  }

  tick(deltaTime) {
    if (!this.running || this.paused) return;

    // Update game time
    this.gameStats.totalPlayTime += deltaTime;

    this.direction = this.nextDirection;
    const head = {
      x: this.snake[0].x + this.direction.x,
      y: this.snake[0].y + this.direction.y
    };

    // Check wall collision
    if (head.x < 0 || head.x >= this.tileCountX || head.y < 0 || head.y >= this.tileCountY) {
      this.gameOver();
      return;
    }

    // Check self collision
    if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      this.gameOver();
      return;
    }

    this.snake.unshift(head);

    // Check apple collision
    if (head.x === this.apple.x && head.y === this.apple.y) {
      this.score++;
      this.updateScore();
      this.apple = this.randomEmptyCell();
      if (this.speed > this.MIN_SPEED) {
        this.speed -= this.SPEED_INCREMENT;
      }
    } else {
      this.snake.pop();
    }
  }

  drawGrid() {
    this.ctx.strokeStyle = '#f0f0f0';
    this.ctx.lineWidth = 1;
    for (let i = 0; i <= this.tileCountX; i++) {
      this.ctx.beginPath();
      this.ctx.moveTo(i * this.tileSize + 0.5, 0);
      this.ctx.lineTo(i * this.tileSize + 0.5, this.canvas.height);
      this.ctx.stroke();
    }
    for (let j = 0; j <= this.tileCountY; j++) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, j * this.tileSize + 0.5);
      this.ctx.lineTo(this.canvas.width, j * this.tileSize + 0.5);
      this.ctx.stroke();
    }
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.drawGrid();

    // Draw apple with glow effect
    const appleX = this.apple.x * this.tileSize + 3;
    const appleY = this.apple.y * this.tileSize + 3;
    const appleSize = this.tileSize - 6;

    // Apple glow
    this.ctx.shadowColor = '#e74c3c';
    this.ctx.shadowBlur = 10;
    this.ctx.fillStyle = '#e74c3c';
    this.ctx.fillRect(appleX, appleY, appleSize, appleSize);
    this.ctx.shadowBlur = 0;

    this.ctx.strokeStyle = '#c0392b';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(appleX, appleY, appleSize, appleSize);

    // Draw snake with gradient effect
    this.snake.forEach((segment, index) => {
      const x = segment.x * this.tileSize + 3;
      const y = segment.y * this.tileSize + 3;
      const size = this.tileSize - 6;

      if (index === 0) {
        // Head - brighter green
        this.ctx.fillStyle = '#2ecc71';
        this.ctx.shadowColor = '#27ae60';
        this.ctx.shadowBlur = 5;
      } else {
        // Body - gradient from green to darker green
        const ratio = index / this.snake.length;
        const green = Math.floor(46 + (46 - 34) * ratio);
        this.ctx.fillStyle = `rgb(39, ${174 + Math.floor((46 - 174) * ratio)}, 60)`;
        this.ctx.shadowBlur = 0;
      }

      this.ctx.fillRect(x, y, size, size);
      this.ctx.strokeStyle = '#229954';
      this.ctx.lineWidth = 1;
      this.ctx.strokeRect(x, y, size, size);
    });

    this.ctx.shadowBlur = 0; // Reset shadow
  }

  gameLoop = (currentTime) => {
    if (this.lastTime === 0) {
      this.lastTime = currentTime;
    }

    const deltaTime = currentTime - this.lastTime;

    if (deltaTime >= this.speed) {
      this.tick(deltaTime);
      this.draw();
      this.lastTime = currentTime;
    }

    if (this.running && !this.paused) {
      this.animationId = requestAnimationFrame(this.gameLoop);
    }
  };

  start() {
    if (this.running) return;
    this.running = true;
    this.paused = false;
    this.startBtn.disabled = true;
    this.pauseBtn.disabled = false;
    this.difficultySelect.disabled = true;
    this.lastTime = 0;
    this.animationId = requestAnimationFrame(this.gameLoop);
  }

  pause() {
    if (!this.running) return;
    this.paused = !this.paused;
    this.pauseBtn.textContent = this.paused ? 'Resume' : 'Pause';
    if (!this.paused) {
      this.lastTime = 0;
      this.animationId = requestAnimationFrame(this.gameLoop);
    }
  }

  reset() {
    cancelAnimationFrame(this.animationId);
    this.gameStats.gamesPlayed++;
    this.gameStats.totalScore += this.score;
    this.saveStats();
    this.updateStatsDisplay();

    this.init();
    this.startBtn.disabled = false;
    this.pauseBtn.disabled = true;
    this.pauseBtn.textContent = 'Pause';
    this.difficultySelect.disabled = false;
  }

  setNextDirection(dx, dy) {
    // Prevent reversing into self
    if ((dx === 1 && this.direction.x === -1) ||
        (dx === -1 && this.direction.x === 1) ||
        (dy === 1 && this.direction.y === -1) ||
        (dy === -1 && this.direction.y === 1)) return;
    this.nextDirection = { x: dx, y: dy };
  }

  bindEvents() {
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      const key = e.key;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(key)) {
        e.preventDefault();
      }
      const lowerKey = key.toLowerCase();
      if (lowerKey === 'w' || key === 'ArrowUp') this.setNextDirection(0, -1);
      else if (lowerKey === 's' || key === 'ArrowDown') this.setNextDirection(0, 1);
      else if (lowerKey === 'a' || key === 'ArrowLeft') this.setNextDirection(-1, 0);
      else if (lowerKey === 'd' || key === 'ArrowRight') this.setNextDirection(1, 0);
      else if (key === ' ') this.pause();
    }, { passive: false });

    // Touch controls
    const buttons = [
      { id: 'btnUp', dx: 0, dy: -1 },
      { id: 'btnLeft', dx: -1, dy: 0 },
      { id: 'btnRight', dx: 1, dy: 0 },
      { id: 'btnDown', dx: 0, dy: 1 }
    ];

    buttons.forEach(({ id, dx, dy }) => {
      const btn = document.getElementById(id);
      if (!btn) return;
      const handler = (ev) => {
        ev.preventDefault();
        this.setNextDirection(dx, dy);
      };
      btn.addEventListener('click', handler);
      btn.addEventListener('touchstart', handler, { passive: false });
    });

    // Swipe on canvas
    let pointerStart = null;
    this.canvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse') return;
      pointerStart = { x: e.clientX, y: e.clientY };
    });
    this.canvas.addEventListener('pointerup', (e) => {
      if (!pointerStart || e.pointerType === 'mouse') return;
      const dx = e.clientX - pointerStart.x;
      const dy = e.clientY - pointerStart.y;
      const absX = Math.abs(dx), absY = Math.abs(dy);
      const threshold = Math.max(12, this.tileSize * 0.4);
      if (Math.max(absX, absY) >= threshold) {
        if (absX > absY) this.setNextDirection(dx > 0 ? 1 : -1, 0);
        else this.setNextDirection(0, dy > 0 ? 1 : -1);
      }
      pointerStart = null;
    });
    this.canvas.addEventListener('pointercancel', () => { pointerStart = null; });

    // Button events
    this.startBtn.addEventListener('click', () => this.start());
    this.pauseBtn.addEventListener('click', () => this.pause());
    this.resetBtn.addEventListener('click', () => this.reset());
    this.difficultySelect.addEventListener('change', () => this.setDifficulty());

    // Resize
    window.addEventListener('resize', () => {
      this.resizeCanvas();
      this.draw();
    });
  }
}

// Initialize the game
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('snakeCanvas');
  if (!canvas) return;

  const scoreEl = document.getElementById('snakeScore');
  const highScoreEl = document.getElementById('highScore');
  const gamesPlayedEl = document.getElementById('gamesPlayed');
  const avgScoreEl = document.getElementById('avgScore');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const startBtn = document.getElementById('startBtn');
  const difficultySelect = document.getElementById('difficulty');

  new SnakeGame(canvas, scoreEl, highScoreEl, pauseBtn, resetBtn, startBtn, difficultySelect);

  // Prevent page scrolling
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
});
</script>
