---
layout: archive
title: "Game"
permalink: /game/
author_profile: true
---

<h3>Games</h3>
<p class="games-intro">Pick a game below to start playing. More titles coming soon.</p>

<!-- Mini Snake Game -->
<div class="mini-snake-section">
  <h4>üéÆ Quick Snake Game</h4>
  <div class="mini-snake-container">
    <canvas id="miniSnakeCanvas" width="300" height="300"></canvas>
    <div class="mini-snake-controls">
      <div class="score-display">Score: <span id="miniScore">0</span></div>
      <div class="control-buttons">
        <button id="miniStartBtn">Start</button>
        <button id="miniResetBtn">Reset</button>
      </div>
    </div>
  </div>
</div>

<style>
  .mini-snake-section {
    margin: 2rem 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 12px;
    border: 1px solid #dee2e6;
  }

  .mini-snake-section h4 {
    margin: 0 0 1rem 0;
    color: #495057;
    font-size: 1.2rem;
  }

  .mini-snake-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }

  #miniSnakeCanvas {
    background: #2c3e50;
    border: 2px solid #34495e;
    border-radius: 8px;
    display: block;
  }

  .mini-snake-controls {
    display: flex;
    gap: 2rem;
    align-items: center;
    justify-content: center;
  }

  .score-display {
    font-weight: bold;
    color: #2c3e50;
    font-size: 1.1rem;
  }

  .control-buttons {
    display: flex;
    gap: 0.5rem;
  }

  .control-buttons button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    background: #3498db;
    color: white;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s ease;
  }

  .control-buttons button:hover {
    background: #2980b9;
  }

  .games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 1.25rem;
    margin-top: 1rem;
  }
  .game-card {
    display: flex;
    flex-direction: column;
    padding: 1.25rem;
    border-radius: 14px;
    text-decoration: none;
    color: inherit;
    background: linear-gradient(135deg, #ffffff 0%, #f6f9fc 100%);
    border: 1px solid #e6ecf1;
    box-shadow: 0 6px 20px rgba(0,0,0,0.06);
    transition: transform .18s ease, box-shadow .18s ease;
    position: relative;
    overflow: hidden;
  }
  .game-card:before {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(600px circle at var(--x, 0) var(--y, 0), rgba(52,152,219,.12), transparent 40%);
    opacity: 0;
    transition: opacity .2s ease;
  }
  .game-card:hover:before { opacity: 1; }
  .game-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 26px rgba(0,0,0,0.10);
  }
  .game-icon {
    font-size: 2rem;
    line-height: 1;
    margin-bottom: .5rem;
  }
  .game-title {
    font-weight: 700;
    font-size: 1.1rem;
    color: #2c3e50;
    margin: 0 0 .25rem 0;
  }
  .game-desc {
    color: #68737d;
    font-size: .95rem;
    margin: 0 0 .75rem 0;
    flex: 1 1 auto;
  }
  .game-actions {
    display: flex;
    justify-content: flex-end;
  }
  .btn-play {
    display: inline-block;
    padding: .5rem 1rem;
    border-radius: 10px;
    background: #3498db;
    color: #fff;
    font-weight: 600;
    border: none;
    box-shadow: 0 3px 10px rgba(52,152,219,.35);
    transition: background .18s ease, transform .18s ease, box-shadow .18s ease;
  }
  .btn-play:hover { background:#2980b9; transform: translateY(-1px); box-shadow: 0 6px 16px rgba(52,152,219,.45); }
  .games-intro { color:#6b7280; }
  @media (max-width: 480px) {
    .game-card { padding: 1rem; }
    .mini-snake-controls { flex-direction: column; gap: 1rem; }
  }
</style>

<div class="games-grid">
  {% assign games = site.data.games %}
  {% if games and games.size > 0 %}
    {% for game in games %}
      {% assign url = game.url | default: '/game/' | append: game.slug | append: '/' %}
      <a href="{{ url }}" class="game-card" onmousemove="this.style.setProperty('--x', (event.clientX - this.getBoundingClientRect().left) + 'px'); this.style.setProperty('--y', (event.clientY - this.getBoundingClientRect().top) + 'px');">
        <div class="game-icon">{{ game.icon | default: 'üéÆ' }}</div>
        <div class="game-title">{{ game.title }}</div>
        <div class="game-desc">{{ game.description }}</div>
        <div class="game-actions">
          <span class="btn-play">Play</span>
        </div>
      </a>
    {% endfor %}
  {% else %}
    <a href="/game/snake/" class="game-card">
      <div class="game-icon">üêç</div>
      <div class="game-title">Snake</div>
      <div class="game-desc">Use WASD keys to move. Eat apples to grow, avoid walls and yourself.</div>
      <div class="game-actions"><span class="btn-play">Play</span></div>
    </a>
  {% endif %}
</div>

<script>
// Mini Snake Game
class MiniSnakeGame {
  constructor(canvas, scoreEl, startBtn, resetBtn) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.scoreEl = scoreEl;
    this.startBtn = startBtn;
    this.resetBtn = resetBtn;

    this.tileCount = 15;
    this.tileSize = this.canvas.width / this.tileCount;

    this.snake = [];
    this.direction = { x: 1, y: 0 };
    this.apple = null;
    this.score = 0;
    this.running = false;
    this.gameLoopId = null;

    this.init();
    this.bindEvents();
  }

  init() {
    const center = Math.floor(this.tileCount / 2);
    this.snake = [
      { x: center, y: center },
      { x: center - 1, y: center },
      { x: center - 2, y: center }
    ];
    this.direction = { x: 1, y: 0 };
    this.apple = this.randomEmptyCell();
    this.score = 0;
    this.running = false;
    this.updateScore();
    this.draw();
  }

  updateScore() {
    if (this.scoreEl) this.scoreEl.textContent = this.score;
  }

  randomEmptyCell() {
    let position;
    do {
      position = {
        x: Math.floor(Math.random() * this.tileCount),
        y: Math.floor(Math.random() * this.tileCount)
      };
    } while (this.snake.some(segment => segment.x === position.x && segment.y === position.y));
    return position;
  }

  gameLoop = () => {
    if (!this.running) return;

    this.move();
    this.checkCollision();
    this.draw();

    setTimeout(this.gameLoop, 150);
  };

  move() {
    const head = {
      x: this.snake[0].x + this.direction.x,
      y: this.snake[0].y + this.direction.y
    };

    this.snake.unshift(head);

    if (head.x === this.apple.x && head.y === this.apple.y) {
      this.score++;
      this.updateScore();
      this.apple = this.randomEmptyCell();
    } else {
      this.snake.pop();
    }
  }

  checkCollision() {
    const head = this.snake[0];

    // Wall collision
    if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
      this.gameOver();
      return;
    }

    // Self collision
    if (this.snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
      this.gameOver();
      return;
    }
  }

  gameOver() {
    this.running = false;
    this.ctx.fillStyle = 'rgba(231, 76, 60, 0.8)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = '#ecf0f1';
    this.ctx.font = 'bold 20px sans-serif';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('Game Over', this.canvas.width / 2, this.canvas.height / 2);
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw grid
    this.ctx.strokeStyle = '#34495e';
    this.ctx.lineWidth = 0.5;
    for (let i = 0; i <= this.tileCount; i++) {
      this.ctx.beginPath();
      this.ctx.moveTo(i * this.tileSize, 0);
      this.ctx.lineTo(i * this.tileSize, this.canvas.height);
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.moveTo(0, i * this.tileSize);
      this.ctx.lineTo(this.canvas.width, i * this.tileSize);
      this.ctx.stroke();
    }

    // Draw apple
    this.ctx.fillStyle = '#e74c3c';
    this.ctx.fillRect(
      this.apple.x * this.tileSize + 2,
      this.apple.y * this.tileSize + 2,
      this.tileSize - 4,
      this.tileSize - 4
    );

    // Draw snake
    this.snake.forEach((segment, index) => {
      this.ctx.fillStyle = index === 0 ? '#27ae60' : '#2ecc71';
      this.ctx.fillRect(
        segment.x * this.tileSize + 2,
        segment.y * this.tileSize + 2,
        this.tileSize - 4,
        this.tileSize - 4
      );
    });
  }

  setDirection(dx, dy) {
    // Prevent reversing
    if ((dx === 1 && this.direction.x === -1) ||
        (dx === -1 && this.direction.x === 1) ||
        (dy === 1 && this.direction.y === -1) ||
        (dy === -1 && this.direction.y === 1)) return;
    this.direction = { x: dx, y: dy };
  }

  start() {
    if (this.running) return;
    this.running = true;
    this.gameLoop();
  }

  reset() {
    this.running = false;
    this.init();
  }

  bindEvents() {
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (!this.running) return;
      switch (e.key.toLowerCase()) {
        case 'w':
        case 'arrowup':
          e.preventDefault();
          this.setDirection(0, -1);
          break;
        case 's':
        case 'arrowdown':
          e.preventDefault();
          this.setDirection(0, 1);
          break;
        case 'a':
        case 'arrowleft':
          e.preventDefault();
          this.setDirection(-1, 0);
          break;
        case 'd':
        case 'arrowright':
          e.preventDefault();
          this.setDirection(1, 0);
          break;
      }
    });

    this.startBtn.addEventListener('click', () => this.start());
    this.resetBtn.addEventListener('click', () => this.reset());
  }
}

// Initialize mini snake game
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('miniSnakeCanvas');
  if (!canvas) return;

  const scoreEl = document.getElementById('miniScore');
  const startBtn = document.getElementById('miniStartBtn');
  const resetBtn = document.getElementById('miniResetBtn');

  new MiniSnakeGame(canvas, scoreEl, startBtn, resetBtn);
});
</script>
